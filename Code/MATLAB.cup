/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/import java.util.*;import java.io.*;import java_cup.runtime.*;import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;import ast.*;import ast.sm.*;import ast.expr.*;parser code {:    Lexer s;    Parser(Lexer s) { this.s = s; }:}/* define how to connect to the scanner! */scan with {: return s.next_token(); :};/* Terminals (tokens returned by the scanner). */terminal            EQUAL, GREATER, SMALLER, G_EQUAL, S_EQUAL, NOT_EQUAL, ASSIGN;terminal            PLUS, MINUS, MULTIPLY, MATRIX_MULTIPLY, DIVIDE, UMINUS;terminal			LPAREN, RPAREN, SEMICOLON, COMMA, COLON, LSQUARE, RSQUARE;terminal            IF, ELSE, FOR, WHILE, END, ALL;terminal Double     NUMBER;terminal String     IDENTIFIER;terminal String		FUNCTION, COMMAND;terminal			POWER, STRING;/* Non terminals */non terminal Program program;non terminal LinkedList<Statement> stmt_list;non terminal Statement stmt;non terminal Expression expr;non terminal LinkedList<Expression> arguments;non terminal LinkedList<MatrixRow> matrix;non terminal MatrixRow matrix_row;/* Precedences */precedence left IF, ELSE, FOR, WHILE, END;precedence left ASSIGN;precedence left EQUAL, GREATER, SMALLER, G_EQUAL, S_EQUAL, NOT_EQUAL;precedence left PLUS, MINUS;precedence left MULTIPLY, MATRIX_MULTIPLY, DIVIDE;precedence left UMINUS;precedence left FUNCTION;precedence left NUMBER, IDENTIFIER;program ::= stmt_list:sl			{: RESULT = new Program(sl); :};stmt_list  ::= stmt_list:sl stmt:s  	{: sl.add(s); RESULT = sl; :}    | /* empty stmt_list */         	{: RESULT = new LinkedList<Statement>(); :};stmt ::= expr:e SEMICOLON	{:    	RESULT = new ExpressionStatement(e);    :}    | IF LPAREN expr:s RPAREN stmt_list:sl ELSE stmt_list:sl2 END     {:    	RESULT = new IfElseStatement(s,sl,sl2);    :}	| IF LPAREN expr:s RPAREN stmt_list:sl END      {:    	RESULT = new IfStatement(s,sl);    :}	| IDENTIFIER:identifier ASSIGN expr:e SEMICOLON	{:		RESULT = new AssignStatement(identifier,e);	:}   	;expr		::= expr:e1 EQUAL  expr:e2   			{: RESULT = new EqualExpression(e1, e2); :}| expr:e1 GREATER  expr:e2   		{: RESULT = new GreaterExpression(e1, e2); :}| expr:e1 SMALLER expr:e2   		{: RESULT = new SmallerExpression(e1, e2); :}| expr:e1 G_EQUAL  expr:e2   		{: RESULT = new GreaterEqualExpression(e1, e2); :}| expr:e1 S_EQUAL  expr:e2   		{: RESULT = new SmallerEqualExpression(e1, e2); :}| expr:e1 NOT_EQUAL  expr:e2   		{: RESULT = new NotEqualExpression(e1, e2); :}| expr:e1 PLUS  expr:e2         	{: RESULT = new PlusExpression(e1, e2); :}| expr:e1 MINUS expr:e2        		{: RESULT = new MinusExpression(e1, e2); :}| expr:e1 MULTIPLY expr:e2  		{: RESULT = new MultiplyExpression(e1, e2); :}| expr:e1 MATRIX_MULTIPLY expr:e2	{: RESULT = new MatrixMultiplyExpression(e1, e2); :}| expr:e1 DIVIDE expr:e2      		{: RESULT = new DivisionExpression(e1, e2); :}| MINUS expr:e                 		{: RESULT = new ComplementExpression(e); :}%prec UMINUS| LPAREN expr:e RPAREN	         	{: RESULT = e; :}| NUMBER:n	                     	{: RESULT = new NumberExpression(n); :}| IDENTIFIER:identifier				{: RESULT = new IdentifierExpression(identifier); :}| LSQUARE matrix:m RSQUARE			{: RESULT = new MatrixExpression(m); :}| FUNCTION:function LPAREN arguments:argList RPAREN{:	RESULT = new FunctionExpression(function, argList);:}| FUNCTION:function LPAREN RPAREN{:	RESULT = new FunctionExpression(function);:};arguments	::=	expr:e{:	LinkedList<Expression> argList = new LinkedList<Expression>();	argList.add(e);	RESULT = argList;:}| arguments:argList COMMA expr:e{:	argList.add(e);	RESULT = argList;:};matrix		::= matrix_row:mr{:	LinkedList<MatrixRow> rowList = new LinkedList<MatrixRow>();	rowList.add(mr);	RESULT = rowList;:}| matrix:rowList SEMICOLON matrix_row:mr{:	rowList.add(mr);	RESULT = rowList;:};matrix_row ::= expr:e{:	MatrixRow row = new MatrixRow();	row.add(e);	RESULT = row;:}| matrix_row:row expr:e{:	row.add(e);	RESULT = row;:}| matrix_row:row COMMA expr:e{:	row.add(e);	RESULT = row;:};